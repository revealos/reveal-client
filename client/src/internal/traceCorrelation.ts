/**
 * Internal module for trace correlation with /decide requests
 *
 * Manages pending trace_id with TTL and consume semantics.
 * This module prevents circular dependencies between entryPoint and decisionClient.
 *
 * @internal
 */

import type { Logger } from '../utils/logger';

/**
 * Internal state for pending trace correlation
 */
let pendingTraceId: string | null = null;
let pendingTraceExpiry: number = 0;
let logger: Logger | undefined = undefined;

/**
 * Set logger instance for trace correlation logging
 * @internal
 */
export function setTraceLogger(loggerInstance: Logger | undefined): void {
  logger = loggerInstance;
}

/**
 * Store a trace ID for correlation with the next /decide request
 *
 * Overwrite semantics: Calling this multiple times overwrites the previous trace_id.
 *
 * @param traceId - UUID generated by requestTrace()
 * @param ttlMs - Time-to-live in milliseconds (typically 60000 = 60s)
 * @internal
 */
export function storePendingTraceId(traceId: string, ttlMs: number): void {
  pendingTraceId = traceId;
  pendingTraceExpiry = Date.now() + ttlMs;

  logger?.logDebug("Stored trace_id", { traceId, ttlMs, expiresAt: new Date(pendingTraceExpiry).toISOString() });
}

/**
 * Consume the pending trace ID if within TTL
 *
 * Consume semantics: Returns trace_id AND clears it immediately,
 * ensuring it's attached to at most one /decide call.
 *
 * @returns trace_id if within TTL, null if expired or already consumed
 * @internal
 */
export function consumePendingTraceId(): string | null {
  // Check if trace_id exists and is within TTL
  if (pendingTraceId === null || Date.now() >= pendingTraceExpiry) {
    // Expired or already consumed
    const reason = pendingTraceId === null ? "already_consumed" : "expired";

    logger?.logDebug("consumePendingTraceId() â†’ null", { reason });

    pendingTraceId = null;
    pendingTraceExpiry = 0;
    return null;
  }

  // Consume: return the value AND clear it
  const traceId = pendingTraceId;
  pendingTraceId = null;
  pendingTraceExpiry = 0;

  logger?.logDebug("Consumed trace_id", { traceId });

  return traceId;
}

/**
 * Reset trace correlation state (for testing only)
 * @internal
 */
export function __TEST_ONLY__resetTraceState(): void {
  pendingTraceId = null;
  pendingTraceExpiry = 0;
}
